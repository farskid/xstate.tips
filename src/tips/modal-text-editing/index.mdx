import { Tip } from "components/Tip";
import { meta } from "./meta";

export default ({ children }) => <Tip meta={meta}>{children}</Tip>;

## What is Modal Editing?

My favorite development tool is the text editor, [Neovim](https://github.com/neovim/neovim). Part of the reason why I enjoy using Neovim so much is the concept of modal editing. Unlike other popular text editors and IDEs, Neovim employs the concepts of _modes_ to maximize the efficiency of the user and extend the functionality of the text editor.

Modal editing means that you are in one editing mode at a time. In the case of Neovim, this means that you are either in `NORMAL`, `INSERT`, `VISUAL`, `VISUAL BLOCK`, `VISUAL LINE`, `COMMAND`, or `REPLACE` mode. While in `INSERT` mode, you can insert text, while in `NORMAL` mode, all your keystrokes are commands, VISUAL modes allow you to select blocks of text, `COMMAND` mode allows you to input editor commands, and `REPLACE` mode allows you to replace the current character under your cursor. Since you can only be in one mode at a time, this is an excellent candidate for modeling with statecharts.

## Benefits of Message Passing

Message passing to communicate state updates is of the advantages to using a state machine to manage the modal editor. It allows use to attach an event listener to all strokes and pipe these events straight into the state machine:

```js
document.body.addEventListener("keyup", changeModes);
function changeModes(e) {
  e.preventDefault();
  // Refers to our xstate service, this will be defined later.
  modalService.send(e.key);
}
```

By passing messages to the state machine, we avoid logic branching altogether: no `if` or `switch` statements, no ternary operators, and perhaps most importantly, our actions are _deterministic_. Determinism gives us confidence that we will never see our editor in a state that is not explicitly defined by our state machine, no matter how many actions we trigger, or in what order they are triggered.

Being able to co-locate all of the state changing actions inside of the state machine also helps when determining which actions are modifying which pieces of state, rather than trying to find this information scattered across different files or different event handlers.

## Creating the Machine

For this example, we won't implement all the modes of Neovim, but instead focus on a subset which captures why it is beneficial to use a state machine to model its behavior.

```js
// MACHINE SETUP -- Note: XState bound to a global object (the library is being served by unpkg)
// *****************************

const { Machine, interpret, assign } = XState;
const modeMachine = Machine(
  {
    id: "modal-editor",
    initial: "normal",
    context: {},
    states: {
      normal: {},
      visual: {},
      insert: {},
      replace: {},
    },
  },
  {
    actions: {},
  }
);
```

Next, since the majority of the logic for this state machine is concerned with manipulating the current view, we want to create functionality for working with the DOM. This will differ depending on your own rendering approach, but the concepts underpinning this behavior will stay the same: update the view as a result of state changes. For this simple example, we will just work with the DOM directly.

```js
// WORKING WITH THE DOM
// *********************************
const terminal = document.getElementById("terminal");
const input = document.getElementsByTagName("input")[0];
const terminalText = terminal.getElementsByTagName("span")[0];
const showmode = document.getElementById("showmode");
const text = document.getElementById("text");
const col = document.getElementById("col");
const cursorTextContent = (textContent) =>
  `<span id="cursor">${textContent}</span>`;
let cursor;
```

Now that we have some building blocks in place, it's time to implement our events on the state machine! Let's start with the most basic, going from insert mode to normal mode.

```js
const modeMachine = Machine(
  {
    id: "modal-editor",
    initial: "normal",
    context: {
      cursorPointer: undefined,
      textContent: "",
      textLength: undefined,
    },
    states: {
      normal: {
        entry: ["applyNormalModeStyles"],
        on: {
          i: "insert",
        }
      },
      visual: {},
      insert: {
        entry: ["getCursorElement", "applyInsertModeStyles"],
        on: {
          Escape: "normal",
        }
      },
      replace: {},
  },
  {
    actions: {
      getCursorElement: () => {
        cursor = document.getElementById("cursor");
      },
      applyInsertModeStyles: () => {
        // Show which mode we're in
        showmode.textContent = "-- INSERT --";
        // Change the cursor from a block to a line
        cursor.style.width = "1.5px";
      },
      applyNormalModeStyles: ({ textContent, cursorPointer, textLength }) => {
        // Set the text showing which row and column our cursor is on.
        // In this basic examle, we won't be implementing rows, so that stays as 1
        col.innerText = `1,${cursorPointer || textLength || 0}`;
        const innerText = (content) => (cursorPointer > 0 ? content : "");
        // Place the cursor block character: █ , over the current text character
        text.innerHTML = textContent
          .slice(0, cursorPointer || textLength)
          .concat(
            cursorTextContent(
              innerText(textContent.slice(cursorPointer, cursorPointer + 1))
            )
          )
          .concat(innerText(textContent.slice(cursorPointer + 1)));
        // nvim does not show the mode text in normal mode
        showmode.textContent = "";
      },
    },
  }
);
```

By sending every keystroke to the machine, we can use the key name as events for our state machine to process. In doing this, we avoid long `switch` or `if` statements and our code becomes easier to read. In the snippet above, the user's keystrokes are directly controlling the machine instead of being processed through logic such as:

```js
if (e.key === "i") modalService.send({ type: "insert" });
if (e.key === "Escape") modalService.send({ type: "normal" });
```

Upon receiving these events, both the `insert` and `normal` states execute two actions: getting a reference to the cursor element, and updating the cursor styles. If we were using a VDOM library for rendering such as React, we wouldn't be manipulating the DOM in these actions, but rather using the `assign` utility to set the values in the machine context for our components to consume. The important thing here is that regardless of how our rendering is being implemented, we are using the actions to initiate a _side effect_ which updates the view.

Continuing this same pattern, let's implement the transitions between the rest of the modes:

```js
const modeMachine = Machine(
  {
    id: "modal-editor",
    initial: "normal",
    context: {
      cursorPointer: undefined,
      textContent: "",
      textLength: undefined,
    },
    states: {
      normal: {
        entry: ["applyNormalModeStyles"],
        on: {
          i: "insert",
          v: "visual",
          R: "replace",
      },
      visual: {
        entry: "applyVisualModeStyles",
        on: { Escape: "normal" },
      },
      insert: {
        entry: ["getCursorElement", "applyInsertModeStyles"],
        on: { Escape: "normal" },
      replace: {
        entry: "applyReplaceModeStyles",
        on: { Escape: "normal" },
      },
    },
  },
  {
    actions: {
     getCursorElement: () => {
        cursor = document.getElementById("cursor");
      },
      applyInsertModeStyles: () => {
        // Show which mode we're in
        showmode.textContent = "-- INSERT --";
        // Change the cursor from a block to a line
        cursor.style.width = "1.5px";
      },
      applyReplaceModeStyles: () => {
        // Show which mode we're in
        showmode.textContent = "-- REPLACE --";
      },
      applyNormalModeStyles: ({ textContent, cursorPointer, textLength }) => {
        // Set the text showing which row and column our cursor is on.
        // In this basic examle, we won't be implementing rows, so that stays as 1
        col.innerText = `1,${cursorPointer || textLength || 0}`;
        const innerText = (content) => (cursorPointer > 0 ? content : "");
        // Place the cursor block character: █ , over the current text character
        text.innerHTML = textContent
          .slice(0, cursorPointer || textLength)
          .concat(
            cursorTextContent(
              innerText(textContent.slice(cursorPointer, cursorPointer + 1))
            )
          )
          .concat(innerText(textContent.slice(cursorPointer + 1)));
        // nvim does not show the mode text in normal mode
        showmode.textContent = "";
      },
      applyVisualModeStyles: () => {
        // Show which mode we're in
        showmode.textContent = "-- VISUAL --";
      },
    },
  }
);
```

```js
// MACHINE SETUP
// *****************************

const { Machine, interpret, assign } = XState;

const modeMachine = Machine(
  {
    id: "modal-editor",
    initial: "normal",
    context: {
      cursorPointer: undefined,
      textContent: "",
      textLength: undefined,
    },
    states: {
      normal: {
        entry: ["applyNormalModeStyles"],
        on: {
          i: "insert",
          v: "visual",
          R: "replace",
          h: {
            target: ".",
            actions: ["moveLeft", "updateCursorPosition"],
            internal: true,
          },
          a: {
            target: "insert",
            actions: ["moveRight", "updateCursorPosition"],
          },
          l: {
            target: ".",
            actions: ["moveRight", "updateCursorPosition"],
            internal: true,
          },
          $: {
            target: ".",
            actions: ["endOfLine", "updateCursorPosition"],
            internal: true,
          },
          0: {
            target: ".",
            actions: ["startOfLine", "updateCursorPosition"],
            internal: true,
          },
        },
      },
      visual: {
        entry: "applyVisualModeStyles",
        on: { Escape: "normal" },
      },
      insert: {
        entry: ["getCursorElement", "applyInsertModeStyles"],
        on: {
          Escape: "normal",
          UPDATE_TEXT: {
            target: ".",
            actions: ["saveText", "updateBuffer"],
          },
        },
      },
      replace: {
        entry: "applyReplaceModeStyles",
        on: { Escape: "normal" },
      },
    },
  },
  {
    actions: {
      saveText: assign(({ cursorPointer, textContent, textLength }, e) => {
        let updatedContent;
        let updatedCursorPointer;
        if (cursorPointer !== undefined && cursorPointer !== textLength) {
          updatedContent = textContent
            .slice(0, cursorPointer)
            .concat(e.data)
            .concat(textContent.slice(cursorPointer));
        } else {
          updatedContent = textContent.concat(e.data);
        }
        if (e.data == null) {
          updatedContent = textContent.slice(0, textLength - 1);
          updatedCursorPointer =
            cursorPointer !== undefined ? cursorPointer - 1 : undefined;
        } else {
          updatedCursorPointer =
            cursorPointer !== undefined ? cursorPointer + 1 : undefined;
        }
        return {
          textContent: updatedContent,
          textLength: updatedContent.length,
          cursorPointer: updatedCursorPointer,
        };
      }),
      updateBuffer: (ctx) => {
        terminalText.textContent = ctx.textContent;
        col.innerText = `1,${ctx.cursorPointer || ctx.textLength || 0}`;
      },
      moveLeft: assign(({ cursorPointer, textLength }) => {
        if (cursorPointer !== undefined) {
          return { cursorPointer: cursorPointer === 0 ? 0 : cursorPointer - 1 };
        }
        return { cursorPointer: textLength - 1 };
      }),
      moveRight: assign(({ cursorPointer, textLength }) => {
        if (cursorPointer !== undefined) {
          return {
            cursorPointer:
              cursorPointer === textLength ? textLength : cursorPointer + 1,
          };
        }
        return { cursorPointer: textLength };
      }),
      endOfLine: assign(({ textLength }) => ({
        cursorPointer: textLength,
      })),
      startOfLine: assign(() => ({
        cursorPointer: 0,
      })),
      getCursorElement: () => {
        cursor = document.getElementById("cursor");
      },
      updateCursorPosition: ({ textContent, cursorPointer, textLength }) => {
        const getInnerText = () => {
          if (cursorPointer !== undefined) {
            return cursorPointer;
          } else if (textLength !== undefined) {
            return textLength;
          }
          return 0;
        };
        col.innerText = `1,${getInnerText()}`;
        text.innerHTML = textContent
          .slice(0, cursorPointer)
          .concat(
            cursorTextContent(
              textContent.slice(cursorPointer, cursorPointer + 1)
            )
          )
          .concat(textContent.slice(cursorPointer + 1));
      },
      applyInsertModeStyles: () => {
        showmode.textContent = "-- INSERT --";
        cursor.style.width = "1.5px";
      },
      applyReplaceModeStyles: () => {
        showmode.textContent = "-- REPLACE --";
      },
      applyNormalModeStyles: ({ textContent, cursorPointer, textLength }) => {
        col.innerText = `1,${cursorPointer || textLength || 0}`;
        const innerText = (content) => (cursorPointer > 0 ? content : "");
        text.innerHTML = textContent
          .slice(0, cursorPointer || textLength)
          .concat(
            cursorTextContent(
              innerText(textContent.slice(cursorPointer, cursorPointer + 1))
            )
          )
          .concat(innerText(textContent.slice(cursorPointer + 1)));
        showmode.textContent = "";
      },
      applyVisualModeStyles: () => {
        showmode.textContent = "-- VISUAL --";
      },
    },
  }
);

// DEBUG UTILS
// *********************************
const debug = document.getElementById("debug");
function showStateDebug(s) {
  debug.textContent = JSON.stringify(s.value, 2, null);
}

// MACHINE STATE in UI
let state;
const modalService = interpret(modeMachine)
  .onTransition((s) => {
    state = s.value;
    showStateDebug(s);
  })
  .start();

// Autofocus input
input.focus();

// HACK always keep invisible input focused
setInterval(() => {
  if (document.activeElement !== input) {
    input.focus();
  }
}, 100);

// Update the terminal value with the text typed in input
input.addEventListener(
  "input",
  (e) => {
    if (state === "insert") {
      modalService.send({ type: "UPDATE_TEXT", data: e.data });
    } else {
      // Do this so we don't have a delay between typing the input and showing the value.
      // Also so that we don't add things to the input that get suddenly appened after entering insert mode
      e.target.value = e.target.value.slice(0, e.target.value.length - 1);
    }
  },
  false
);

document.body.addEventListener("keyup", changeModes);
function changeModes(e) {
  e.preventDefault();
  modalService.send(e.key);
}
```
