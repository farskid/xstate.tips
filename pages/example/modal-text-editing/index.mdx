import { Tip } from "../../../components/Tip";
import { meta } from "./meta";

export default ({ children }) => <Tip meta={meta}>{children}</Tip>;

## What is Modal Editing?

My favorite development tool is the text editor, [Neovim](https://github.com/neovim/neovim). Part of the reason why I enjoy using Neovim so much is the concept of modal editing. Unlike other popular text editors and IDEs, Neovim employs the concepts of _modes_ to maximize the efficiency of the user and extend the functionality of the text editor.

Modal editing means that you are in one editing mode at a time. In the case of Neovim, this means that you are either in `NORMAL`, `INSERT`, `VISUAL`, `VISUAL BLOCK`, `VISUAL LINE`, `COMMAND`, or `REPLACE` mode. While in `INSERT` mode, you can insert text, while in `NORMAL` mode, all your keystrokes are commands, VISUAL modes allow you to select blocks of text, `COMMAND` mode allows you to input editor commands, and `REPLACE` mode allows you to replace the current character under your cursor. Since you can only be in one mode at a time, this is an excellent candidate for modeling with statecharts.

## Benefits of Message Passing

Message passing to communicate state updates is of the advantages to using a state machine to manage the modal editor. It allows use to attach an event listener to all strokes and pipe these events straight into the state machine:

```js
document.body.addEventListener("keyup", changeModes);
function changeModes(e) {
  e.preventDefault();
  // Refers to our xstate service, this will be defined later.
  modalService.send(e.key);
}
```

By passing messages to the state machine, we avoid logic branching altogether: no `if` or `switch` statements, no ternary operators, and perhaps most importantly, our actions are _deterministic_. Determinism gives us confidence that we will never see our editor in a state that is not explicitly defined by our state machine, no matter how many actions we trigger, or in what order they are triggered.

Being able to co-locate all of the state changing actions inside of the state machine also helps when determining which actions are modifying which pieces of state, rather than trying to find this information scattered across different files or different event handlers.

## Creating the Machine

For this example, we won't implement all the modes of Neovim, but instead focus on a subset which captures why it beneficial to use a state machine to model its behavior.

```js
// MACHINE SETUP -- Note: XState bound to a global object (the library is being served by unpkg)
// *****************************
//
const { Machine, interpret, assign } = XState;
const modeMachine = Machine(
  {
    id: "modal-editor",
    initial: "normal",
    context: {},
    states: {
      normal: {},
      visual: {},
      insert: {},
      replace: {},
    },
  },
  {
    actions: {},
  }
);
```

Next, we want to create functionality for working with the DOM. This will differ depending on your own rendering approach, but the concepts underpinning this behavior will stay the same: update the view as a result of state changes. For this simple example, we will just work with the DOM directly.

```js
// WORKING WITH THE DOM
// *********************************
const terminal = document.getElementById("terminal");
const input = document.getElementsByTagName("input")[0];
const terminalText = terminal.getElementsByTagName("span")[0];
const showmode = document.getElementById("showmode");
const text = document.getElementById("text");
const col = document.getElementById("col");
const cursorTextContent = (textContent) =>
  `<span id="cursor">${textContent}</span>`;
let cursor;
```

Now that we have some building blocks in place, it's time to implement our events on the state machine! Let's start with the most basic, going from insert mode to normal mode.

```js
// MACHINE SETUP
// *****************************
//
const { Machine, interpret, assign } = XState;

const modeMachine = Machine(
  {
    id: "modal-editor",
    initial: "normal",
    context: {
      cursorPointer: undefined,
      textContent: "",
      textLength: undefined,
    },
    states: {
      normal: {
        entry: ["applyNormalModeStyles"],
        on: {
          i: "insert",
          v: "visual",
          R: "replace",
          h: {
            target: ".",
            actions: ["moveLeft", "updateCursorPosition"],
            internal: true,
          },
          a: {
            target: "insert",
            actions: ["moveRight", "updateCursorPosition"],
          },
          l: {
            target: ".",
            actions: ["moveRight", "updateCursorPosition"],
            internal: true,
          },
          $: {
            target: ".",
            actions: ["endOfLine", "updateCursorPosition"],
            internal: true,
          },
          0: {
            target: ".",
            actions: ["startOfLine", "updateCursorPosition"],
            internal: true,
          },
        },
      },
      visual: {
        entry: "applyVisualModeStyles",
        on: { Escape: "normal" },
      },
      insert: {
        entry: ["getCursorElement", "applyInsertModeStyles"],
        on: {
          Escape: "normal",
          UPDATE_TEXT: {
            target: ".",
            actions: ["saveText", "updateBuffer"],
          },
        },
      },
      replace: {
        entry: "applyReplaceModeStyles",
        on: { Escape: "normal" },
      },
    },
  },
  {
    actions: {
      saveText: assign(({ cursorPointer, textContent, textLength }, e) => {
        let updatedContent;
        let updatedCursorPointer;
        if (cursorPointer !== undefined && cursorPointer !== textLength) {
          updatedContent = textContent
            .slice(0, cursorPointer)
            .concat(e.data)
            .concat(textContent.slice(cursorPointer));
        } else {
          updatedContent = textContent.concat(e.data);
        }
        if (e.data == null) {
          updatedContent = textContent.slice(0, textLength - 1);
          updatedCursorPointer =
            cursorPointer !== undefined ? cursorPointer - 1 : undefined;
        } else {
          updatedCursorPointer =
            cursorPointer !== undefined ? cursorPointer + 1 : undefined;
        }
        return {
          textContent: updatedContent,
          textLength: updatedContent.length,
          cursorPointer: updatedCursorPointer,
        };
      }),
      updateBuffer: (ctx) => {
        terminalText.textContent = ctx.textContent;
        col.innerText = `1,${ctx.cursorPointer || ctx.textLength || 0}`;
      },
      moveLeft: assign(({ cursorPointer, textLength }) => {
        if (cursorPointer !== undefined) {
          return { cursorPointer: cursorPointer === 0 ? 0 : cursorPointer - 1 };
        }
        return { cursorPointer: textLength - 1 };
      }),
      moveRight: assign(({ cursorPointer, textLength }) => {
        if (cursorPointer !== undefined) {
          return {
            cursorPointer:
              cursorPointer === textLength ? textLength : cursorPointer + 1,
          };
        }
        return { cursorPointer: textLength };
      }),
      endOfLine: assign(({ textLength }) => ({
        cursorPointer: textLength,
      })),
      startOfLine: assign(() => ({
        cursorPointer: 0,
      })),
      getCursorElement: () => {
        cursor = document.getElementById("cursor");
      },
      updateCursorPosition: ({ textContent, cursorPointer, textLength }) => {
        const getInnerText = () => {
          if (cursorPointer !== undefined) {
            return cursorPointer;
          } else if (textLength !== undefined) {
            return textLength;
          }
          return 0;
        };
        col.innerText = `1,${getInnerText()}`;
        text.innerHTML = textContent
          .slice(0, cursorPointer)
          .concat(
            cursorTextContent(
              textContent.slice(cursorPointer, cursorPointer + 1)
            )
          )
          .concat(textContent.slice(cursorPointer + 1));
      },
      applyInsertModeStyles: () => {
        showmode.textContent = "-- INSERT --";
        cursor.style.width = "1.5px";
      },
      applyReplaceModeStyles: () => {
        showmode.textContent = "-- REPLACE --";
      },
      applyNormalModeStyles: ({ textContent, cursorPointer, textLength }) => {
        col.innerText = `1,${cursorPointer || textLength || 0}`;
        const innerText = (content) => (cursorPointer > 0 ? content : "");
        text.innerHTML = textContent
          .slice(0, cursorPointer || textLength)
          .concat(
            cursorTextContent(
              innerText(textContent.slice(cursorPointer, cursorPointer + 1))
            )
          )
          .concat(innerText(textContent.slice(cursorPointer + 1)));
        showmode.textContent = "";
      },
      applyVisualModeStyles: () => {
        showmode.textContent = "-- VISUAL --";
      },
    },
  }
);

// DEBUG UTILS
// *********************************
const debug = document.getElementById("debug");
function showStateDebug(s) {
  debug.textContent = JSON.stringify(s.value, 2, null);
}

// MACHINE STATE in UI
let state;
const modalService = interpret(modeMachine)
  .onTransition((s) => {
    state = s.value;
    showStateDebug(s);
  })
  .start();

// Autofocus input
input.focus();

// HACK always keep invisible input focused
setInterval(() => {
  if (document.activeElement !== input) {
    input.focus();
  }
}, 100);

// Update the terminal value with the text typed in input
input.addEventListener(
  "input",
  (e) => {
    if (state === "insert") {
      modalService.send({ type: "UPDATE_TEXT", data: e.data });
    } else {
      // Do this so we don't have a delay between typing the input and showing the value.
      // Also so that we don't add things to the input that get suddenly appened after entering insert mode
      e.target.value = e.target.value.slice(0, e.target.value.length - 1);
    }
  },
  false
);

document.body.addEventListener("keyup", changeModes);
function changeModes(e) {
  e.preventDefault();
  modalService.send(e.key);
}
```
